#pragma config(Sensor, in1,    LeftPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    RightPot,       sensorPotentiometer)
#pragma config(Sensor, in3,    SwingPot,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  LeftEnc,        sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightEnc,       sensorQuadEncoder)
#pragma config(Motor,  port1,           mogo1,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           LeftOutsideD,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           LeftInsideD,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           RightInsideD,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           RightOutsideD, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           LeftLift,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           RightLift,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           Swing,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           Intake,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          mogo2,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

// init numCons to 1 and stacking to false so robot doesnt try to autostack
int numCones = 1;
bool stacking = false;

/*/////////////////////////////////////////////////////////////
pre autonomous task
reset sensor values/initializations here
*//////////////////////////////////////////////////////////////
void driveforward(int speed, int target)
{
	while(SensorValue(LeftEnc) < target)
	{
		motor[LeftInsideD] = (SensorValue(LeftEnc) - target);
		motor[LeftOutsideD] = (SensorValue(LeftEnc) - target);
		motor[RightInsideD] = (SensorValue(LeftEnc) - target);
		motor[RightOutsideD] = (SensorValue(LeftEnc) - target);
		wait1Msec(20);
	}
	motor[LeftInsideD] = -10;
	motor[LeftOutsideD] = -10;
	motor[RightInsideD] = -10;
	motor[RightOutsideD] = -10;
	wait1Msec(20);
	return;
}

void drivereverse(int speed, int target)
{
	while(SensorValue(LeftEnc) < target)
	{
		motor[LeftInsideD] = -(SensorValue(LeftEnc) - target);
		motor[LeftOutsideD] = -(SensorValue(LeftEnc) - target);
		motor[RightInsideD] = -(SensorValue(LeftEnc) - target);
		motor[RightOutsideD] = -(SensorValue(LeftEnc) - target);
		wait1Msec(20);
	}
	motor[LeftInsideD] = 10;
	motor[LeftOutsideD] = 10;
	motor[RightInsideD] = 10;
	motor[RightOutsideD] = 10;
	wait1Msec(20);
	return;
}

void rightturn(int speed, int target)
{
	while(SensorValue(LeftEnc) < target)
	{
		motor[LeftInsideD] = (SensorValue(LeftEnc) - target);
		motor[LeftOutsideD] = (SensorValue(LeftEnc) - target);
		motor[RightInsideD] = -(SensorValue(LeftEnc) - target);
		motor[RightOutsideD] = -(SensorValue(LeftEnc) - target);
		wait1Msec(20);
	}
	motor[LeftInsideD] = -10;
	motor[LeftOutsideD] = -10;
	motor[RightInsideD] = 10;
	motor[RightOutsideD] = 10;
	wait1Msec(20);
	return;
}

void leftturn(int speed, int target)
{
	while(SensorValue(LeftEnc) < target)
	{
		motor[LeftInsideD] = -(SensorValue(LeftEnc) - target);
		motor[LeftOutsideD] = -(SensorValue(LeftEnc) - target);
		motor[RightInsideD] = (SensorValue(LeftEnc) - target);
		motor[RightOutsideD] = (SensorValue(LeftEnc) - target);
		wait1Msec(20);
	}
	motor[LeftInsideD] = 10;
	motor[LeftOutsideD] = 10;
	motor[RightInsideD] = -10;
	motor[RightOutsideD] = -10;
	wait1Msec(20);
	return;
}

void pre_auton()
{
	bStopTasksBetweenModes = true;
}

/*/////////////////////////////////////////////////////////////
autonomous mode task
code here runs during the autonomous period of the match
*//////////////////////////////////////////////////////////////
task autonomous()
{
	numCones = 1;
}

/*/////////////////////////////////////////////////////////////
auto stacking task
this code relies on the press of a button and the current number
of cones stacked on the mobile goal. pressing button 5U executes
the whole code.
*//////////////////////////////////////////////////////////////
task autostack()
{
	// establish heights for the lift and the swinging arm positions
	int coneHeight[9] = { 70, 220, 330, 410, 605, 700, 1000, 1100, 1550}; //30, 190, 460, 755, 940, 1130, 1370, 1610
	int SwingHigh = 4000;
	int CurrentL = SensorValue[LeftPot];
	int CurrentS = SensorValue[SwingPot];

	// runs until lift reaches target and swing arm reaches top position
	while((SensorValue[LeftPot] < coneHeight[numCones] -50) || (SensorValue[LeftPot] > coneHeight[numCones] + 50))
	{

		CurrentL = SensorValue[LeftPot];
		CurrentS = SensorValue[SwingPot];
		wait1Msec(20);

		// if lift height is below target lift up higher
		if(SensorValue[LeftPot] < coneHeight[numCones])
		{
			motor[LeftLift] = (coneHeight[numCones] - CurrentL)*100 ;
			motor[RightLift] = (coneHeight[numCones] - CurrentL)*100 ;
			wait1Msec(20);
		}
		// if lift height is above target lift down lower
		else if(SensorValue[LeftPot] > coneHeight[numCones])
		{
			motor[LeftLift] = -(coneHeight[numCones] - CurrentL)*100 ;
			motor[RightLift] = -(coneHeight[numCones] - CurrentL)*100 ;
			wait1Msec(20);
		}

		motor[Swing] = 30 ;
		motor[Intake] = -30;
	}
	motor[LeftLift] = -10;
	motor[RightLift] = -10;
	motor[Swing] = -10;
	wait1Msec(100);

	CurrentS  = SensorValue[SwingPot];
	while(CurrentS < SwingHigh)
	{
		CurrentS  = SensorValue[SwingPot];
		// if swing arm is not at high position lift up
		if(CurrentS < SwingHigh)
		{
			motor[Swing] = abs(SwingHigh - CurrentS) * 20;
			wait1Msec(20);
		}

		// hold the up position
		else
		{
			motor[Swing] = 20;
			wait1Msec(20);
		}

		motor[LeftLift] = 20;
		motor[RightLift] = 20;
	}

	// start lifting down
	motor[Intake] = 127;
	wait1Msec(500);

	// add one to numCones to signify it was stacked
	if (numCones < 7)
	{
		++numCones;
	}
	stacking = false;
	wait1Msec(20);

	// end task
	stopTask(autostack);
}

/*/////////////////////////////////////////////////////////////
Driver control task
code here runs during the driver period of the match
*//////////////////////////////////////////////////////////////
task usercontrol()
{

	int x;
	int y;
	int CurrentS;
	int CurrentL;

	// set lift and swing heights
	int SwingMid = 3700;
	int SwingHigh = 4000;
	int SwingLow = 3300;
	int thresh = 10;
	stacking = false;
	numCones = 1;

	// big ole while loop
	while (true)
	{
		// constantly set current swing and lift heights
		CurrentS = SensorValue[SwingPot];
		CurrentL = SensorValue[LeftPot];

		// make joystick move far enough before using values
		if(abs(vexRT[Ch3]) >= thresh)
		{
			y = vexRT[Ch3];
		}
		else
		{
			y = 0;
		}
		// make joystick move far enough before using values
		if(abs(vexRT[Ch2]) >= thresh)
		{
			x = vexRT[Ch1];
		}
		else
		{
			x = 0;
		}

		// set motor values for arcade drive
		motor[LeftInsideD] = y + x;
		motor[LeftOutsideD] = y + x;
		motor[RightInsideD] = y - x;
		motor[RightOutsideD] = y - x;

		// mobile goal lift up
		if(vexRT[Btn8L] == 1)
		{
			motor[mogo1] = 127;
			motor[mogo2] = 127;
		}

		// mobile goal lift down and reset number of cones on drop off
		else if(vexRT[Btn8R] == 1)
		{
			motor[mogo1] = -127;
			motor[mogo2] = -127;
			numCones = 1;
		}

		/*/ subtract one cone from total
		else if(vexRT[Btn7D] == 1)
		{
			numCones--;
		}
		else if(vexRT[Btn7L] == 1)
		{
			numCones++;
	}
	*/

		// stop
		else
		{
			motor[mogo1] = 0;
			motor[mogo2] = 0;
		}

		// run auto stack code
		//*
		if(vexRT[Btn7U] == 1)
		{
			stacking = true;
			startTask(autostack);
		}
		//*/

		//*
		if(vexRT[Btn5U] == 1)
		{
			if(CurrentS < SwingHigh)
			{
				motor[Swing] = abs(SwingHigh - CurrentS) /2 ;
			}
			// when above target position swing down
			else	if(CurrentS > SwingHigh)
			{
				motor[Swing] = -1 * abs(SwingHigh - CurrentS) /6 ;
			}
		}
		//*/

		// if not running auto stack code
		else if(stacking == false)
		{
			if(vexRT[Btn7L] == 1){
				numCones--;
			}
			// swing arm down
			if(vexRT[Btn5D] == 1)
			{
				if(CurrentS < SwingLow)
				{
					motor[Swing] = abs(SwingLow - CurrentS) /2 ;
				}
				// when above target position swing down
				else	if(CurrentS > SwingLow)
				{
					motor[Swing] = -1 * abs(SwingLow - CurrentS) /6 ;
					
				}
				motor[Intake] = -127;
				if(SensorValue[LeftLift] > 800)
				{
				motor[LeftLift] = -127;
				motor[RightLift] = -127;
				}
				else
				{
					motor[LeftLift] = -63;
					motor[RightLift] = -63;
				}
				wait1Msec(20);
			}

			// maintain mid position
			else
			{
				// when below target position swing up
				if(CurrentS < SwingMid)
				{
					motor[Swing] = abs(SwingMid - CurrentS) /2 ;
				}
				// when above target position swing down
				else	if(CurrentS > SwingMid)
				{
					motor[Swing] = -1 * abs(SwingMid - CurrentS) /6 ;
				}
			}
		}

		// when not auto stacking
		if (stacking == false)
		{
			// lift up
			if(vexRT[Btn6U] == 1 )
			{
				motor[LeftLift] = 127;
				motor[RightLift] = 127;
			}
			// lift down
			else if(vexRT[Btn6D] == 1)
			{
				motor[LeftLift] = -127;
				motor[RightLift] = -127;
			}
			else
			{
				motor[LeftLift] = 0;
				motor[RightLift] = 0;
			}
		}
		if (stacking == false)
		{
			if(vexRT[Btn8D] == 1)
			{
				motor[Intake] = 60;
			}
			else if(vexRT[Btn8U] == 1)
			{
				motor[Intake] = -60		;
			}
			else
			{
				motor[Intake] = -20;
			}
		}
	}
}
