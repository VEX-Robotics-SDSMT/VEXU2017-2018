#pragma config(Sensor, in1,    LeftPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    RightPot,       sensorPotentiometer)
#pragma config(Sensor, in3,    SwingPot,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  piston,         sensorDigitalOut)
#pragma config(Sensor, dgtl2,  leftEnc,        sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  rightEnc,       sensorQuadEncoder)
#pragma config(Motor,  port2,           frontDriveLeft, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           frontDriveRight, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           liftLeft,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           liftRight,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           roller,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           mogo,          tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rearDriveLeft, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           rearDriveRight, tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*/////////////////////////////////////////////////////////////
pre autonomous task
reset sensor values/initializations here
*//////////////////////////////////////////////////////////////



void driveForward(int speed, int target)
{
	SensorValue(leftEnc) = 0;
	SensorValue(rightEnc) = 0;
	int leftVal = abs(SensorValue(leftEnc));
	int rightVal = abs(SensorValue(rightEnc));
	
	while(leftVal < target)
	{
		leftVal = abs(SensorValue(leftEnc));
		rightVal = abs(SensorValue(rightEnc));
		
		//if encoder values are not equal
		if(leftVal > rightVal)
		{
			//slow down left slightly
			motor[frontDriveRight] = (leftVal - target) * speed;
			motor[frontDriveLeft] = (leftVal - target) * speed * .75;
			motor[rearDriveRight] = (leftVal - target) * speed;
			motor[rearDriveLeft] = (leftVal - target) * speed * .75;
		}
		else if(rightVal > leftVal)
		{	
			//slow down right slightly
			motor[frontDriveRight] = (leftVal - target) * speed * .75;
			motor[frontDriveLeft] = (leftVal - target) * speed;
			motor[rearDriveRight] = (leftVal - target) * speed * .75;
			motor[rearDriveLeft] = (leftVal - target) * speed;
		}
		else
		{
			//go same speed on both
			motor[frontDriveRight] = (leftVal - target) * speed;
			motor[frontDriveLeft] = (leftVal - target) * speed;
			motor[rearDriveRight] = (leftVal - target) * speed;
			motor[rearDriveLeft] = (leftVal - target) * speed;
			wait1Msec(20);
		}
	}
	//reverse wheels to prevent sliding
	motor[frontDriveRight] = -10;
	motor[frontDriveLeft] = -10;
	motor[rearDriveRight] = -10;
	motor[rearDriveLeft] = -10;
	wait1Msec(20);
	
	//set motor speeds to 0
	motor[frontDriveRight] = 0;
	motor[frontDriveLeft] = 0;
	motor[rearDriveRight] = 0;
	motor[rearDriveLeft] = 0;
	wait1Msec(20);
	
	return;
}

void driveReverse(int speed, int target)
{
	SensorValue(leftEnc) = 0;
	SensorValue(rightEnc) = 0;
	int leftVal = abs(SensorValue(leftEnc));
	int rightVal = abs(SensorValue(rightEnc));
	
	while(leftVal < target)
	{
		leftVal = abs(SensorValue(leftEnc));
		rightVal = abs(SensorValue(rightEnc));
		
		//if left further ahead than right
		if(leftVal > rightVal)
		{
			//slow down left slightly
			motor[frontDriveRight] = -((leftVal - target) * speed);
			motor[frontDriveLeft] = -((leftVal - target) * speed * .75);
			motor[rearDriveRight] = -((leftVal - target) * speed);
			motor[rearDriveLeft] = -((leftVal - target) * speed * .75);
		}
		else if (rightVal > leftVal)
		{
			//slow down right slightly
			motor[frontDriveRight] = -((leftVal - target) * speed * .75);
			motor[frontDriveLeft] = -((leftVal - target) * speed);
			motor[rearDriveRight] = -((leftVal - target) * speed * .75);
			motor[rearDriveLeft] = -((leftVal - target) * speed);
		}
		else
		{
			//go same speed on both
			motor[frontDriveRight] = -((leftVal - target) * speed);
			motor[frontDriveLeft] = -((leftVal - target) * speed);
			motor[rearDriveRight] = -((leftVal - target) * speed);
			motor[rearDriveLeft] = -((leftVal - target) * speed);
			wait1Msec(20);
		}
	}
	//spin backward to prevent sliding
	motor[frontDriveRight] = 10;
	motor[frontDriveLeft] = 10;
	motor[rearDriveRight] = 10;
	motor[rearDriveLeft] = 10;
	wait1Msec(20);
	
	//set motor speed to 0
	motor[frontDriveRight] = 0;
	motor[frontDriveLeft] = 0;
	motor[rearDriveRight] = 0;
	motor[rearDriveLeft] = 0;
	wait1Msec(20);
	return;
}

void rightTurn(int speed, int target)
{
		SensorValue(leftEnc) = 0;
	SensorValue(rightEnc) = 0;
	while(SensorValue(leftEnc) < target)
	{
		motor[frontDriveRight] = (SensorValue(leftEnc) - target);
		motor[frontDriveLeft] = (SensorValue(leftEnc) - target);
		motor[rearDriveRight] = -(SensorValue(leftEnc) - target);
		motor[rearDriveLeft] = -(SensorValue(leftEnc) - target);
		wait1Msec(20);
	}
	motor[frontDriveRight] = -10;
	motor[frontDriveLeft] = -10;
	motor[rearDriveRight] = 10;
	motor[rearDriveLeft] = 10;
	wait1Msec(20);
	return;
}

void leftTurn(int speed, int target)
{
		SensorValue(leftEnc) = 0;
	SensorValue(rightEnc) = 0;
	
	while(SensorValue(leftEnc) < target)
	{
		motor[frontDriveRight] = -(SensorValue(leftEnc) - target);
		motor[frontDriveLeft] = -(SensorValue(leftEnc) - target);
		motor[rearDriveRight] = (SensorValue(leftEnc) - target);
		motor[rearDriveLeft] = (SensorValue(leftEnc) - target);
		wait1Msec(20);
	}
	motor[frontDriveRight] = 10;
	motor[frontDriveLeft] = 10;
	motor[rearDriveRight] = -10;
	motor[rearDriveLeft] = -10;
	wait1Msec(20);
	return;
}

void pre_auton()
{
	bStopTasksBetweenModes = true;
}

/*/////////////////////////////////////////////////////////////
autonomous mode task
code here runs during the autonomous period of the match
*//////////////////////////////////////////////////////////////
task autonomous() //autn
{

}

/*/////////////////////////////////////////////////////////////
auto stacking task
this code relies on the press of a button and the current number
of cones stacked on the mobile goal. pressing button 7U executes
the whole code.
*//////////////////////////////////////////////////////////////
task autostack() //stk
{
	motor[roller] = 20;
	
	//lift up
	motor[liftLeft] = 127;
	motor[liftRight] = 127;
	wait1Msec(10); //TODO change to proper amount
	motor[liftLeft] = 0;
	motor[liftRight] = 0;
	
	//swing to middle
	SensorValue[piston] = 1;
	wait1Msec(10); //TODO change
	
	//lift down
	motor[liftLeft] = -127;
	motor[liftRight] = -127;
	wait1Msec(10); //TODO change to proper amount
	motor[liftLeft] = 0;
	motor[liftRight] = 0;
	
	//drop cone
	motor[roller] = -127;
	wait1Msec(10); //TODO set to proper amount
	motor[roller] = 0;
	
	//lift up
	motor[liftLeft] = 127;
	motor[liftRight] = 127;
	wait1Msec(10); //change to proper amount
	motor[liftLeft] = 0;
	motor[liftRight] = 0;
	
	//swing to side
	SensorValue[piston] = 0;
	
	//lift down
	motor[liftLeft] = -127;
	motor[liftRight] = -127;
	wait1Msec(10); //TODO change to proper amount
	motor[liftLeft] = 0;
	motor[liftRight] = 0;
}

/*/////////////////////////////////////////////////////////////
Driver control task
code here runs during the driver period of the match
*//////////////////////////////////////////////////////////////
task usercontrol()
{
	int x;
	int y;
	int thresh = 10;

	// big ole while loop
	while (true)
	{
		// make joystick move far enough before using values
		if(abs(vexRT[Ch3]) >= thresh)
		{
			y = vexRT[Ch3];
		}
		else
		{
			y = 0;
		}

		// make joystick move far enough before using values
		if(abs(vexRT[Ch2]) >= thresh)
		{
			x = vexRT[Ch1];
		}
		else
		{
			x = 0;
		}

		// set motor values for arcade drive
		motor[frontDriveRight] = y - x;
		motor[frontDriveLeft] = y + x;
		motor[rearDriveRight] = y - x;
		motor[rearDriveLeft] = y + x;

		//mobile goal code
		//mobile goal lift up
		if(vexRT[Btn8U] == 1)
		{
			motor[mogo] = 127;
		}
		// mobile goal lift down
		else if(vexRT[Btn8D] == 1)
		{
			motor[mogo] = -127;
		}
		else
		{
			motor[mogo] = 0;
		}
		
		
		//roller code
		//roller up
			if(vexRT[Btn5U] == 1)
		{
			motor[roller] = 127;
		}
		//roller down
		else if(vexRT[Btn5D] == 1)
		{
			motor[roller] = -127;
		}
		else
		{
			motor[roller] = 0;
		}
		
		
		//lift code
		//lift up
			if(vexRT[Btn6U] == 1)
		{
			motor[liftLeft] = 127;
			motor[liftRight] = 127;
		}
		//lift down
		else if(vexRT[Btn6D] == 1)
		{
			motor[liftLeft] = -127;
			motor[liftRight] = -127;
		}
		else
		{
			motor[liftLeft] = 0;
			motor[liftRight] = 0;
		}
		
		
	}
}
