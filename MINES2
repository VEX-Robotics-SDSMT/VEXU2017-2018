#pragma config(Sensor, in1,    LeftPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    RightPot,       sensorPotentiometer)
#pragma config(Sensor, in3,    SwingPot,       sensorPotentiometer)
#pragma config(Motor,  port1,           mogo1,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           LeftOutsideD,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           LeftInsideD,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           RightInsideD,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           RightOutsideD, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           LeftLift,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           RightLift,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           Swing,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          mogo2,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

int i = 0;

void pre_auton()
{
	bStopTasksBetweenModes = true;
}

task autonomous()
{
	i = 0;
}

task autostack()
{
	int coneHeight[12] = { 0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100 };
	int SwingHigh = 3000;
	int SwingMid = 1500;

	while(SensorValue[LeftPot] < coneHeight[i] && SensorValue[SwingPot] < SwingHigh)
	{
		int CurrentL = SensorValue[LeftPot];
		int CurrentR = SensorValue[RightPot];
		int CurrentS = SensorValue[SwingPot];


		if(CurrentL < coneHeight[i])
		{
			if(CurrentL > CurrentR)
			{
				motor[LeftLift] = (abs(coneHeight[i] - CurrentL) - abs(CurrentL - CurrentR)) / 10;
				motor[RightLift] = (abs(coneHeight[i] - CurrentL) + abs(CurrentL - CurrentR)) / 10;
			}
			else	if(CurrentL > CurrentR)
			{
				motor[LeftLift] = (abs(coneHeight[i] - CurrentL) + abs(CurrentL - CurrentR)) / 10;
				motor[RightLift] = (abs(coneHeight[i] - CurrentL) - abs(CurrentL - CurrentR)) / 10;
			}
			else
			{
				motor[LeftLift] = (abs(coneHeight[i] - CurrentL) ) / 10;
				motor[RightLift] = (abs(coneHeight[i] - CurrentL) ) / 10;
			}
		}
		if(coneHeight[i] - CurrentL < 500)
		{
			if(CurrentS < SwingHigh)
			{
				motor[Swing] = abs(SwingHigh - CurrentS) / 10;
			}
			else
			{
				motor[Swing] = 20;
			}
		}
		else
		{
			if(CurrentS < SwingMid)
			{
				motor[Swing] = abs(SwingMid - CurrentS) / 10;
			}
			else	if(CurrentS > SwingMid)
			{
				motor[Swing] = -1 * abs(SwingMid - CurrentS) / 10;
			}
			else
			{
				motor[Swing] = 0;
			}
		}
	}

	while(SensorValue[LeftPot] > coneHeight[i-1])
	{
		int CurrentL = SensorValue[LeftPot];
		int CurrentR = SensorValue[RightPot];

		if(CurrentL > CurrentR)
		{
			motor[LeftLift] = -(abs(coneHeight[i] - CurrentL) - abs(CurrentL - CurrentR)) / 10;
			motor[RightLift] = -(abs(coneHeight[i] - CurrentL) + abs(CurrentL - CurrentR)) / 10;
		}
		else	if(CurrentL > CurrentR)
		{
			motor[LeftLift] = -(abs(coneHeight[i] - CurrentL) + abs(CurrentL - CurrentR)) / 10;
			motor[RightLift] = -(abs(coneHeight[i] - CurrentL) - abs(CurrentL - CurrentR)) / 10;
		}
		else
		{
			motor[LeftLift] = -(abs(coneHeight[i] - CurrentL) - abs(CurrentL - CurrentR)) / 10;
			motor[RightLift] = -(abs(coneHeight[i] - CurrentL) + abs(CurrentL - CurrentR)) / 10;
		}
	}

	while(SensorValue[LeftPot] > 0 && SensorValue[SwingPot] > SwingMid)
	{
		int CurrentL = SensorValue[LeftPot];
		int CurrentR = SensorValue[RightPot];
		int CurrentS = SensorValue[SwingPot];

		if(CurrentL < coneHeight[i])
		{
			if(CurrentL > CurrentR)
			{
				motor[LeftLift] = - (abs(coneHeight[i] - CurrentL) - abs(CurrentL - CurrentR)) / 10;
				motor[RightLift] = - (abs(coneHeight[i] - CurrentL) + abs(CurrentL - CurrentR)) / 10;
			}
			else	if(CurrentL > CurrentR)
			{
				motor[LeftLift] = -(abs(coneHeight[i] - CurrentL) + abs(CurrentL - CurrentR)) / 10;
				motor[RightLift] = -(abs(coneHeight[i] - CurrentL) - abs(CurrentL - CurrentR)) / 10;
			}
			else
			{
				motor[LeftLift] = -(abs(coneHeight[i] - CurrentL) - abs(CurrentL - CurrentR)) / 10;
				motor[RightLift] = -(abs(coneHeight[i] - CurrentL) + abs(CurrentL - CurrentR)) / 10;
			}
		}

		if(CurrentS < SwingMid)
		{
			motor[Swing] = abs(SwingMid - CurrentS) / 10;
		}
		else	if(CurrentS > SwingMid)
		{
			motor[Swing] = -1 * abs(SwingMid - CurrentS) / 10;
		}
		else
		{
			motor[Swing] = 0;
		}
	}

	++i;

	stopTask(autostack);
}

task usercontrol()
{
	int x;
	int y;
	int j = 0;
	int CurrentS = SensorValue[SwingPot];
	int SwingMid = 1500;
	int thresh = 10;

	while (true)
	{
		if(abs(vexRT[Ch3]) >= thresh)
		{
			y = vexRT[Ch3];
			y = vexRT[Ch3];
		}
		else
		{
			y = 0;
			y = 0;
		}

		if(abs(vexRT[Ch2]) >= thresh)
		{
			x = vexRT[Ch1];
			x = vexRT[Ch1];
		}
		else
		{
			x = 0;
			x = 0;
		}

		motor[LeftInsideD] = y + x;
		motor[LeftOutsideD] = y + x;
		motor[RightInsideD] = y - x;
		motor[RightOutsideD] = y - x;


		if(vexRT[Btn8U] == 1)
		{
			motor[mogo1] = 127;
			motor[mogo2] = 127;
		}
		else if(vexRT[Btn8D] == 1)
		{
			motor[mogo1] = -127;
			motor[mogo2] = -127;
		}
		else
		{
			motor[mogo1] = 0;
			motor[mogo2] = 0;
		}

		if(vexRT[Btn5U] == 1)
		{
			j = 1;
			startTask(autostack);
			
		}

		else if(j == 0 && vexRT[Btn5D] == 1)
		{
			motor[Swing] = -127;
		}

		else if (j == 0)
		{
			if(CurrentS < SwingMid)
			{
				motor[Swing] = abs(SwingMid - CurrentS) / 10;
			}
			else	if(CurrentS > SwingMid)
			{
				motor[Swing] = -1 * abs(SwingMid - CurrentS) / 10;
			}
			else
			{
				motor[Swing] = 0;
			}
		}
	}
}
