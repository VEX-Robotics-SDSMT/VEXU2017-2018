#pragma config(Sensor, in1,    MogoPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    SwingPot,       sensorPotentiometer)
#pragma config(Sensor, in3,    LiftPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           RightRearDrive2, tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           LeftRearDrive1, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           RightFrontDrive2, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           Mogo,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           RightFrontDrive1, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           LeftFrontDrive1, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           Mogo2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LeftFrontDrive2, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           RightRearDrive1, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          LeftRearDrive2, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

// Tune these values. Higher Value = higher speed but more inaccuracy
const float LKP = 10;
const float RKP = 10;
const float Error = .5;

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	slaveMotor(LeftFrontDrive2, LeftFrontDrive1);
	slaveMotor(LeftRearDrive2, LeftFrontDrive1);
	slaveMotor(LeftRearDrive1, LeftFrontDrive1);
	slaveMotor(RightFrontDrive2, RightFrontDrive1);
	slaveMotor(RightRearDrive2, RightFrontDrive1);
	slaveMotor(RightRearDrive1, RightFrontDrive1);

}

void forward(int target)
{
	// initializing powers and sensorvalues to 0
	int powerleft = 0;
	int powerright = 0;
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;

	// until robot hasn't reached target
	while(abs(SensorValue[leftEncoder]) < target)
	{

		// if left side gets ahead
		if( abs(SensorValue[leftEncoder]) > abs(SensorValue[leftEncoder]))
		{
			// calculate power for left side
			powerleft = abs(target - SensorValue[leftEncoder]) * LKP * Error;
			if(powerleft < 30)
			{
				powerleft = 30;
			}

			// calculate power for right side
			powerright = abs(target - SensorValue[rightEncoder]) * RKP;
			if(powerright < 30)
			{
				powerright = 30;
			}

			// assign motors power
			if(abs(SensorValue[leftEncoder]) < 400)
			{
				motor[LeftFrontDrive1] = powerleft * .3;
				motor[RightFrontDrive1] = powerright * .3;
			}
			else
			{
				motor[LeftFrontDrive1] = powerleft;
				motor[RightFrontDrive1] = powerright;
			}
		}

		// if right side gets ahead
		else if( abs(SensorValue[leftEncoder]) > abs(SensorValue[leftEncoder]))
		{
			// calculate power for left side
			powerleft = abs(target - SensorValue[leftEncoder]) * LKP ;
			if(powerleft < 30)
			{
				powerleft = 30;
			}

			// calculate power for right side
			powerright = abs(target - SensorValue[rightEncoder]) * RKP * Error;
			if(powerright < 30)
			{
				powerright = 30;
			}

			// assign motors power
			if(abs(SensorValue[leftEncoder]) < 400)
			{
				motor[LeftFrontDrive1] = powerleft * .3;
				motor[RightFrontDrive1] = powerright * .3;
			}
			else
			{
				motor[LeftFrontDrive1] = powerleft;
				motor[RightFrontDrive1] = powerright;
			}
		}

		// if left and right are equal
		else
		{
			// calculate power for left side
			powerleft = abs(target - SensorValue[leftEncoder]) * LKP ;
			if(powerleft < 30)
			{
				powerleft = 30;
			}

			// calculate power for right side
			powerright = abs(target - SensorValue[rightEncoder]) * RKP;
			if(powerright < 30)
			{
				powerright = 30;
			}

			// assign motors power
			if(abs(SensorValue[leftEncoder]) < 400)
			{
				motor[LeftFrontDrive1] = powerleft * .3;
				motor[RightFrontDrive1] = powerright * .3;
			}
			else
			{
				motor[LeftFrontDrive1] = powerleft;
				motor[RightFrontDrive1] = powerright;
			}
		}

	}

	// brief brake
	motor[LeftFrontDrive1] = -20;
	motor[RightFrontDrive1] = -20;
	wait1Msec(100);

	// stop motors
	motor[LeftFrontDrive1] = 0;
	motor[RightFrontDrive1] = 0;
	wait1Msec(100);
}

void backward(int target)
{
	// initializing powers and sensorvalues to 0
	int powerleft = 0;
	int powerright = 0;
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;

	// until robot hasn't reached target
	while(abs(SensorValue[leftEncoder]) < target)
	{

		// if left side gets ahead
		if( abs(SensorValue[leftEncoder]) > abs(SensorValue[leftEncoder]))
		{
			// calculate power for left side
			powerleft = abs(target - SensorValue[leftEncoder]) * LKP * Error;
			if(powerleft < 30)
			{
				powerleft = 30;
			}

			// calculate power for right side
			powerright = abs(target - SensorValue[rightEncoder]) * RKP;
			if(powerright < 30)
			{
				powerright = 30;
			}

			// assign motors power
			if(abs(SensorValue[leftEncoder]) < 400)
			{
				motor[LeftFrontDrive1] = -powerleft * .3;
				motor[RightFrontDrive1] = -powerright * .3;
			}
			else
			{
				motor[LeftFrontDrive1] = -powerleft;
				motor[RightFrontDrive1] = -powerright;
			}
		}

		// if right side gets ahead
		else if( abs(SensorValue[leftEncoder]) > abs(SensorValue[leftEncoder]))
		{
			// calculate power for left side
			powerleft = abs(target - SensorValue[leftEncoder]) * LKP ;
			if(powerleft < 30)
			{
				powerleft = 30;
			}

			// calculate power for right side
			powerright = abs(target - SensorValue[rightEncoder]) * RKP * Error;
			if(powerright < 30)
			{
				powerright = 30;
			}

			// assign motors power
			if(abs(SensorValue[leftEncoder]) < 400)
			{
				motor[LeftFrontDrive1] = -powerleft * .3;
				motor[RightFrontDrive1] = -powerright * .3;
			}
			else
			{
				motor[LeftFrontDrive1] = -powerleft;
				motor[RightFrontDrive1] = -powerright;
			}
		}

		// if left and right are equal
		else
		{
			// calculate power for left side
			powerleft = abs(target - SensorValue[leftEncoder]) * LKP ;
			if(powerleft < 30)
			{
				powerleft = 30;
			}

			// calculate power for right side
			powerright = abs(target - SensorValue[rightEncoder]) * RKP;
			if(powerright < 30)
			{
				powerright = 30;
			}

			// assign motors power
			if(abs(SensorValue[leftEncoder]) < 400)
			{
				motor[LeftFrontDrive1] = -powerleft * .3;
				motor[RightFrontDrive1] = -powerright * .3;
			}
			else
			{
				motor[LeftFrontDrive1] = -powerleft;
				motor[RightFrontDrive1] = -powerright;
			}
		}

	}

	// brief brake
	motor[LeftFrontDrive1] = 20;
	motor[RightFrontDrive1] = 20;
	wait1Msec(100);

	// stop motors
	motor[LeftFrontDrive1] = 0;
	motor[RightFrontDrive1] = 0;
	wait1Msec(100);
}

void left(int target)
{
	// initializing powers and sensorvalues to 0
	int powerleft = 0;
	int powerright = 0;
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;

	// until robot hasn't reached target
	while(abs(SensorValue[leftEncoder]) < target)
	{

		// if left side gets ahead
		if( abs(SensorValue[leftEncoder]) > abs(SensorValue[leftEncoder]))
		{
			// calculate power for left side
			powerleft = abs(target - SensorValue[leftEncoder]) * LKP * Error;
			if(powerleft < 30)
			{
				powerleft = 30;
			}

			// calculate power for right side
			powerright = abs(target - SensorValue[rightEncoder]) * RKP;
			if(powerright < 30)
			{
				powerright = 30;
			}

			// assign motors power
			if(abs(SensorValue[leftEncoder]) < 400)
			{
				motor[LeftFrontDrive1] = -powerleft * .3;
				motor[RightFrontDrive1] = powerright * .3;
			}
			else
			{
				motor[LeftFrontDrive1] = -powerleft;
				motor[RightFrontDrive1] = powerright;
			}
		}

		// if right side gets ahead
		else if( abs(SensorValue[leftEncoder]) > abs(SensorValue[leftEncoder]))
		{
			// calculate power for left side
			powerleft = abs(target - SensorValue[leftEncoder]) * LKP ;
			if(powerleft < 30)
			{
				powerleft = 30;
			}

			// calculate power for right side
			powerright = abs(target - SensorValue[rightEncoder]) * RKP * Error;
			if(powerright < 30)
			{
				powerright = 30;
			}

			// assign motors power
			if(abs(SensorValue[leftEncoder]) < 400)
			{
				motor[LeftFrontDrive1] = -powerleft * .3;
				motor[RightFrontDrive1] = powerright * .3;
			}
			else
			{
				motor[LeftFrontDrive1] = -powerleft;
				motor[RightFrontDrive1] = powerright;
			}
		}

		// if left and right are equal
		else
		{
			// calculate power for left side
			powerleft = abs(target - SensorValue[leftEncoder]) * LKP;
			if(powerleft < 30)
			{
				powerleft = 30;
			}

			// calculate power for right side
			powerright = abs(target - SensorValue[rightEncoder]) * RKP ;
			if(powerright < 30)
			{
				powerright = 30;
			}

			// assign motors power
			if(abs(SensorValue[leftEncoder]) < 400)
			{
				motor[LeftFrontDrive1] = -powerleft * .3;
				motor[RightFrontDrive1] = powerright * .3;
			}
			else
			{
				motor[LeftFrontDrive1] = -powerleft;
				motor[RightFrontDrive1] = powerright;
			}
		}

	}

	// brief brake
	motor[LeftFrontDrive1] = 20;
	motor[RightFrontDrive1] = -20;
	wait1Msec(100);

	// stop motors
	motor[LeftFrontDrive1] = 0;
	motor[RightFrontDrive1] = 0;
	wait1Msec(100);
}

void right(int target)
{
	// initializing powers and sensorvalues to 0
	int powerleft = 0;
	int powerright = 0;
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;

	// until robot hasn't reached target
	while(abs(SensorValue[leftEncoder]) < target)
	{

		// if left side gets ahead
		if( abs(SensorValue[leftEncoder]) > abs(SensorValue[leftEncoder]))
		{
			// calculate power for left side
			powerleft = abs(target - SensorValue[leftEncoder]) * LKP * Error;
			if(powerleft < 30)
			{
				powerleft = 30;
			}

			// calculate power for right side
			powerright = abs(target - SensorValue[rightEncoder]) * RKP;
			if(powerright < 30)
			{
				powerright = 30;
			}

			// assign motors power
			if(abs(SensorValue[leftEncoder]) < 400)
			{
				motor[LeftFrontDrive1] = powerleft * .3;
				motor[RightFrontDrive1] = -powerright * .3;
			}
			else
			{
				motor[LeftFrontDrive1] = powerleft;
				motor[RightFrontDrive1] = -powerright;
			}
		}

		// if right side gets ahead
		else if( abs(SensorValue[leftEncoder]) > abs(SensorValue[leftEncoder]))
		{
			// calculate power for left side
			powerleft = abs(target - SensorValue[leftEncoder]) * LKP ;
			if(powerleft < 30)
			{
				powerleft = 30;
			}

			// calculate power for right side
			powerright = abs(target - SensorValue[rightEncoder]) * RKP * Error;
			if(powerright < 30)
			{
				powerright = 30;
			}

			// assign motors power
			if(abs(SensorValue[leftEncoder]) < 400)
			{
				motor[LeftFrontDrive1] = powerleft * .3;
				motor[RightFrontDrive1] = -powerright * .3;
			}
			else
			{
				motor[LeftFrontDrive1] = powerleft;
				motor[RightFrontDrive1] = -powerright;
			}
		}

		// if left and right are equal
		else
		{
			// calculate power for left side
			powerleft = abs(target - SensorValue[leftEncoder]) * LKP ;
			if(powerleft < 30)
			{
				powerleft = 30;
			}

			// calculate power for right side
			powerright = abs(target - SensorValue[rightEncoder]) * RKP;
			if(powerright < 30)
			{
				powerright = 30;
			}

			// assign motors power
			if(abs(SensorValue[leftEncoder]) < 400)
			{
				motor[LeftFrontDrive1] = powerleft * .3;
				motor[RightFrontDrive1] = -powerright * .3;
			}
			else
			{
				motor[LeftFrontDrive1] = powerleft;
				motor[RightFrontDrive1] = -powerright;
			}
		}

	}

	// brief brake
	motor[LeftFrontDrive1] = -20;
	motor[RightFrontDrive1] = 20;
	wait1Msec(100);

	// stop motors
	motor[LeftFrontDrive1] = 0;
	motor[RightFrontDrive1] = 0;
	wait1Msec(100);
}

task mogodown()
{
	motor[Mogo] = -127;
	motor[Mogo2] = -127;
	wait1Msec(600);
	motor[Mogo] = -20;
	motor[Mogo2] = -20;
	wait1Msec(10);
	stopTask(mogodown);
}

task mogoup()
{
	motor[Mogo] = 127;
	motor[Mogo2] = 127;
	wait1Msec(700);
	motor[Mogo] = 20;
	motor[Mogo2] = 20;
	wait1Msec(10);
	stopTask(mogoup);
}

task autonomous()
{

startTask(mogodown);
forward(850);
motor[LeftFrontDrive1] = 20;
motor[RightFrontDrive1] = 20;
startTask(mogoup);
wait1Msec(600);
backward(750);
left(75);
backward(175);
left(100);
forward(175);
startTask(mogodown);
wait1Msec(300);
backward(20);

// score 1st

backward(200);
right(330);
forward(350);
startTask(mogoup);
motor[LeftFrontDrive1] = 20;
motor[RightFrontDrive1] = 20;
wait1Msec(600);
backward(420);
left(100);
backward(170);
left(140);
forward(450);
startTask(mogodown);
wait1Msec(300);
backward(300);

//score 2nd

startTask(mogoup);
motor[LeftFrontDrive1] = 30;
motor[RightFrontDrive1] = 30;
wait1Msec(500);

motor[LeftFrontDrive1] = 0;
motor[RightFrontDrive1] = 0;
wait1Msec(10);

backward(100);
left(150);
forward(200);
left(170);
startTask(mogodown);
wait1Msec(200);
forward(500);
motor[LeftFrontDrive1] = 20;
motor[RightFrontDrive1] = 20;
startTask(mogoup);
wait1Msec(600);

backward(500);
right(300);
forward(250);
startTask(mogodown);
wait1Msec(300);

//score third

backward(300);
startTask(mogoup);
wait1Msec(500);
left(50);
forward(250);
wait1Msec(1000);
backward(75);
left(170);

startTask(mogodown);
forward(600);
motor[LeftFrontDrive1] = 20;
motor[RightFrontDrive1] = 20;
startTask(mogoup);
wait1Msec(600);

backward(750);
right(75);
backward(175);
right(100);
forward(175);
startTask(mogodown);
wait1Msec(300);
backward(20);


}

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{
		int y;
		int x;
		int threshhigh = 100;
		int threshlow = 20;
		while (true)
		{
			// make joystick move far enough before using values
			if(abs(vexRT[Ch3]) >= threshhigh)
			{
				y = vexRT[Ch3] * .8;
			}
			else if(abs(vexRT[Ch3]) <= threshlow)
			{
				y = 0;
			}
			else
			{
				y = vexRT[Ch3];
			}
			// make joystick move far enough before using values
			if(abs(vexRT[Ch1]) >= threshhigh)
			{
				x = vexRT[Ch1] * .8;
			}
			else if(abs(vexRT[Ch1]) <= threshlow)
			{
				x = 0;
			}

			else
			{
				x = vexRT[Ch1];
			}

			motor[LeftFrontDrive1] = x + y;
			motor[LeftFrontDrive2] = x + y;
			motor[RightFrontDrive1] = -x + y;
			motor[RightFrontDrive2] = -x + y;
			motor[LeftRearDrive1] = x + y;
			motor[LeftRearDrive2] = x + y;
			motor[RightRearDrive1] = -x + y;
			motor[RightRearDrive2] = -x + y;

			if(vexRT[Btn6U] == 1)
			{
				motor[Mogo] = 127;
				motor[Mogo2] = 127;
			}
			else if(vexRT[Btn6D] == 1)
			{
				motor[Mogo] = -127;
				motor[Mogo2] = -127;
			}
			else
			{
				motor[Mogo] = 0;
				motor[Mogo2] = 0;
			}
		}
	}
}
